generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ==================== AUTH & CORE ====================

model RefreshToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String   @db.Uuid
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([token])
}

model User {
  id         String  @id @default(uuid()) @db.Uuid
  email      String  @unique
  phone      String?
  password   String
  location   String?
  firstName  String  @map("first_name")
  middleName String? @map("middle_name")
  lastName   String  @map("last_name")
  avatarUrl  String? @map("avatar_url")
  role       Role    @default(USER)
  
  // NEW: User type flags
  isAgent    Boolean @default(false)  // Real estate agent
  isInventor Boolean @default(false) // Furniture maker/custom items seller
  isFurnitureMaker Boolean @default(false)

  ownedProperties Item[] @relation("OwnerRelation")
  agentListings   Item[] @relation("AgentRelation")

  receiptProofsAsBuyer    ReceiptProof[]   @relation("ReceiptBuyer")
  receiptProofsAsReviewer ReceiptProof[]   @relation("ReceiptReviewer")
  termsAgreements         TermsAgreement[]

  failedLoginAttempts Int            @default(0)
  accountLockedUntil  DateTime?
  refreshTokens       RefreshToken[]
  lastLoginAttempt    DateTime?

  interests        PropertyInterest[]   @relation("UserInterests")
  sentMessages     ChatMessage[]        @relation("SentMessages")
  receivedMessages ChatMessage[]        @relation("ReceivedMessages")
  purchases        Sale[]               @relation("Purchases")
  sales            Sale[]               @relation("Sales")
  auditLogs        AuditLog[]           @relation("UserAuditLogs")
  propertyViews    PropertyView[]       @relation("UserPropertyViews")
  engagements      PropertyEngagement[] @relation("UserEngagements")

  itemsCreated Item[] @relation("ItemCreatedBy")

  // NEW: payments, commissions, finance reviews
  payments             Payment[]
  adminCommissions     Commission[] @relation("AdminCommissions")
  financeReviewedSales Sale[]       @relation("FinanceReviewedSales")

  viewingFeePayments   ViewingFeePayment[] @relation("UserViewingFees")
  
  // NEW: Virtual Assistant Chat
  virtualAssistantChats VirtualAssistantChat[] @relation("UserVAChats")
  
  // NEW: Household items / custom items
  householdItemsSold    HouseholdItem[] @relation("HouseholdItemSeller")
  householdItemsPurchased HouseholdItemOrder[] @relation("HouseholdItemBuyer")
  householdItemsCreated HouseholdItem[] @relation("HouseholdItemCreatedBy")
  
  // NEW: Agent assignments for household items
  assignedHouseholdOrders HouseholdItemOrder[] @relation("AssignedAgent")
  
  // NEW: Reserved properties (real estate reservation fee)
  reservedProperties Item[] @relation("ReservationUser")
  reservationFeePayments ReservationFeePayment[] @relation("ReservationFeePayments")
  
  // NEW: Chat System - Real Estate
  chatsAsUser               Chat[]                @relation("ChatUser")
  chatsAsAgent              Chat[]                @relation("ChatAgent")
  chatsClosedByAdmin        Chat[]                @relation("ChatClosedByAdmin")
  sentChatMessages          ChatMessageModel[]    @relation("ChatMessageSender")
  ratingsGiven              UserRating[]          @relation("UserGivenRatings")
  ratingsReceived           UserRating[]          @relation("UserReceivedRatings")
  agentStats                AgentStatistics?      @relation("AgentStats")
  activityLogs              AgentActivityLog[]    @relation("AgentActivityLogs")
  reportsFiled              ConversationReport[]  @relation("UserReports")
  reportedFor               ConversationReport[]  @relation("AgentReportedFor")
  reportsReviewed           ConversationReport[]  @relation("AdminReviews")
  agentFeePayments          AgentFeePayment[]     @relation("AgentFeePayments")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  passwordResetToken          String?   @unique
  passwordResetTokenExpiresAt DateTime?

  isEmailVerified                 Boolean   @default(false)
  emailVerificationToken          String?   @unique
  emailVerificationTokenExpiresAt DateTime?
}

enum Role {
  USER
  SELLER
  ADMIN
  SUPER_ADMIN
}

// ==================== ITEMS / PROPERTIES ====================

model Item {
  id          String     @id @default(uuid()) @db.Uuid
  title       String
  shortDesc   String
  longDesc    String
  dos         String?
  donts       String?
  price       Float
  location    String
  contactInfo String?
  status      ItemStatus @default(PENDING)
  isFeatured  Boolean    @default(false)

  rentStartDate      DateTime?
  rentEndDate        DateTime?
  rentDurationMonths Int?
  autoReopenAt       DateTime?

  category ItemCategory @default(FOR_SALE)
  itemType ItemType     @default(HOUSE)

  bedrooms     Int?
  bathrooms    Int?
  sqft         Float?
  propertyType String?

  viewCount          Int       @default(0)
  uniqueViewCount    Int       @default(0)
  interestedCount    Int       @default(0)
  whatsappClickCount Int       @default(0)
  lastViewedAt       DateTime?

  interests   PropertyInterest[]   @relation("PropertyInterests")
  messages    ChatMessage[]        @relation("PropertyMessages")
  sales       Sale[]               @relation("PropertySales")
  views       PropertyView[]       @relation("PropertyViews")
  engagements PropertyEngagement[] @relation("PropertyEngagements")

  agentCommissionPercent   Float @default(0)
  companyCommissionPercent Float @default(0)
  ownerCommissionPercent   Float @default(0)
  platformFeePercent       Float @default(0)

  landlordLinks   PropertyToLandlord[]
  receiptProofs   ReceiptProof[]
  termsAgreements TermsAgreement[]

  ownerId String? @db.Uuid
  owner   User?   @relation("OwnerRelation", fields: [ownerId], references: [id], onDelete: SetNull)

  agentId String? @db.Uuid
  agent   User?   @relation("AgentRelation", fields: [agentId], references: [id], onDelete: SetNull)

  // NEW: payments related to this property
  payments Payment[]
  viewingFeePayments ViewingFeePayment[] @relation("PropertyViewingFees")
  
  // NEW: Real Estate Reservation Fee System (for house renting/selling)
  reservationFeeAmount    Float                   @default(10000)  // ₦10,000 NON-REFUNDABLE fee
  reservationFeeStatus    ReservationFeeStatus?
  reservationFeePaidAt    DateTime?
  
  // Track which user has active reservation
  currentReservationBy    String?                 @db.Uuid
  reservationUser         User?                   @relation("ReservationUser", fields: [currentReservationBy], references: [id], onDelete: SetNull)
  
  // Reservation timeline
  reservationStartedAt    DateTime?
  reservationExpiresAt    DateTime?               // 7 days from start
  
  // For when user doesn't like property
  reservationRefundedAt   DateTime?
  reservationRefundReason String?
  
  // Agent viewing
  agentViewingScheduledAt DateTime?
  agentViewingCompletedAt DateTime?
  agentViewingApproved    Boolean?
  
  // Property lock (shows PENDING to others)
  isReserved              Boolean                 @default(false)
  
  // Reservation fee payments
  reservationFeePayments  ReservationFeePayment[] @relation("PropertyReservationFees")
  
  // NEW: Chat System
  chats                   Chat[]                  @relation("ChatProperty")

  isDeleted      Boolean   @default(false)
  deletedAt      DateTime?
  deletedBy      String?   @db.Uuid
  deletionReason String?

  createdBy     String? @db.Uuid
  createdByUser User?   @relation("ItemCreatedBy", fields: [createdBy], references: [id])

  images ItemImage[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([isDeleted])
  @@index([itemType])
  @@index([category])
  @@index([currentReservationBy])
  @@index([isReserved])
}

model ItemImage {
  id    String @id @default(uuid()) @db.Uuid
  url   String
  order Int    @default(0)

  itemId String @db.Uuid
  item   Item   @relation(fields: [itemId], references: [id])
}

enum ItemStatus {
  PENDING
  AVAILABLE
  SOLD
  REJECTED
  RENTED
}

enum ItemCategory {
  FOR_SALE
  FOR_RENT
  SHORT_STAY
}

enum ItemType {
  HOUSE
  HOUSEHOLD_ITEM
}

// ==================== HOUSEHOLD ITEMS (NEW) ====================

model HouseholdItem {
  id          String                @id @default(uuid()) @db.Uuid
  title       String
  description String                @db.Text
  price       Float
  location    String?
  
  // Type: STOCK or CUSTOM
  type        HouseholdItemType     @default(STOCK)
  status      HouseholdItemStatus   @default(AVAILABLE)
  
  // For CUSTOM items
  productionDaysMin Int?              // 10 days min
  productionDaysMax Int?              // 30 days max
  customizationOptions Json?          // Available colors, sizes, materials
  
  // Images
  images      HouseholdItemImage[]
  
  // Seller info
  sellerId    String                @db.Uuid
  seller      User                  @relation("HouseholdItemSeller", fields: [sellerId], references: [id], onDelete: Cascade)
  createdBy   String?               @db.Uuid
  createdByUser User?               @relation("HouseholdItemCreatedBy", fields: [createdBy], references: [id])
  
  // Virtual assistant chats about this item
  virtualAssistantChats VirtualAssistantChat[] @relation("ItemVAChats")
  
  // Orders/purchases
  orders      HouseholdItemOrder[]  @relation("ItemOrders")
  
  viewCount   Int                   @default(0)
  
  isDeleted   Boolean               @default(false)
  deletedAt   DateTime?
  
  createdAt   DateTime              @default(now())
  updatedAt   DateTime              @updatedAt
  
  @@index([type])
  @@index([status])
  @@index([sellerId])
  @@index([isDeleted])
}

enum HouseholdItemType {
  STOCK        // Already exists, single item
  CUSTOM       // Made-to-order, can make unlimited
}

enum HouseholdItemStatus {
  AVAILABLE    // Can order
  DELISTED     // Seller removed it
  ARCHIVED     // Old item
}

model HouseholdItemImage {
  id          String              @id @default(uuid()) @db.Uuid
  url         String
  order       Int                 @default(0)
  itemId      String              @db.Uuid
  item        HouseholdItem       @relation(fields: [itemId], references: [id], onDelete: Cascade)
  
  @@index([itemId])
}

// Orders for household items (like sales for real estate)
model HouseholdItemOrder {
  id                String                  @id @default(uuid()) @db.Uuid
  
  itemId            String                  @db.Uuid
  item              HouseholdItem           @relation("ItemOrders", fields: [itemId], references: [id], onDelete: Cascade)
  
  buyerId           String                  @db.Uuid
  buyer             User                    @relation("HouseholdItemBuyer", fields: [buyerId], references: [id], onDelete: Cascade)
  
  sellerId          String                  @db.Uuid
  
  // Agent assignment (MANDATORY)
  assignedAgentId   String?                 @db.Uuid
  assignedAgent     User?                   @relation("AssignedAgent", fields: [assignedAgentId], references: [id], onDelete: SetNull)
  
  // Order amount
  amount            Float                   // Total price
  
  // Payment tracking
  payments          HouseholdItemPayment[]
  
  // CUSTOM items only
  customizations    Json?                   // {color: "black", size: "3-seater", material: "leather"}
  
  // Status tracking
  status            HouseholdItemOrderStatus @default(PAYMENT_PENDING)
  
  // Payment tracking
  paymentStatus     PaymentStatus           @default(PENDING)
  paymentId         String?                 @db.Uuid
  paidAt            DateTime?
  
  // For CUSTOM items - production tracking
  productionStatus  CustomProductionStatus? @default(NOT_STARTED)
  productionStartedAt DateTime?
  expectedCompletionDate DateTime?
  
  // Day 21: Final photos (for custom)
  finalPhotosUrl    String[]                // Array of photo URLs
  finalPhotosApprovedAt DateTime?
  finalPhotosApprovalStatus CustomPhotoApprovalStatus?
  finalPhotosRejectionReason String?
  
  // For STOCK items - delivery & agent verification
  deliveryStatus    StockDeliveryStatus?
  verifiedByAgentAt DateTime?
  agentVerificationNotes String?
  
  // REFUND POLICY (STOCK ITEMS ONLY)
  isItemNew         Boolean?                // Is this a new item (eligible for 3-day refund)?
  refundEligibleUntil DateTime?              // 3 days after delivery (only for new items)
  refundRequested   Boolean @default(false) // User requested refund
  refundRequestedAt DateTime?
  refundAmount      Float?
  refundReason      String?
  refundedAt        DateTime?
  refundStatus      RefundStatus?           // PENDING, APPROVED, REJECTED
  
  // AGENT PAYMENT (Only paid after 3 days with no complaints)
  agentFeeAmount    Float?                  // Agent commission
  agentFeePaid      Boolean @default(false) // Paid only after 3-day window with no complaints
  agentFeePaidAt    DateTime?
  complaintRaised   Boolean @default(false) // Did buyer raise complaint within 3 days?
  complaintRaisedAt DateTime?
  complaintReason   String?
  
  // Completion
  completedAt       DateTime?
  agentCompletionNotes String?
  
  createdAt         DateTime                @default(now())
  updatedAt         DateTime                @updatedAt
  
  @@index([itemId])
  @@index([buyerId])
  @@index([status])
  @@index([paymentStatus])
  @@index([productionStatus])
  @@map("household_item_orders")
}

enum HouseholdItemOrderStatus {
  PAYMENT_PENDING         // User hasn't paid yet
  PAYMENT_CONFIRMED       // User paid H12
  AGENT_CONTACTED         // Agent is contacted (for both stock & custom)
  AGENT_MEETING_SCHEDULED // For STOCK: meeting scheduled with agent
  AGENT_VERIFICATION_PENDING // For STOCK: waiting for agent to verify
  PRODUCTION_IN_PROGRESS  // For CUSTOM: maker is building
  AWAITING_FINAL_PHOTOS   // For CUSTOM: waiting for Day 21 photos
  FINAL_PHOTOS_APPROVED   // For CUSTOM: user approved photos
  AWAITING_DELIVERY       // For both: ready to deliver
  DELIVERED               // Item delivered/received
  COMPLETED               // Deal done
  CANCELLED               // User cancelled
  DISPUTED                // Dispute filed
  REFUNDED                // Refund processed
}

enum CustomProductionStatus {
  NOT_STARTED
  MATERIALS_SOURCING      // Days 1-5
  FRAME_ASSEMBLY          // Days 6-10
  UPHOLSTERY_WORK         // Days 11-18
  QUALITY_CHECK           // Days 19-20
  FINAL_PHOTOS_READY      // Day 21
  READY_FOR_DELIVERY      // After approval
}

enum CustomPhotoApprovalStatus {
  PENDING                 // Waiting for user approval
  APPROVED                // User approved
  CHANGES_REQUESTED       // User wants changes
  CHANGES_COMPLETED       // Changes made
  REJECTED                // User rejected
}

enum StockDeliveryStatus {
  AWAITING_AGENT_VERIFICATION
  AGENT_VERIFIED
  READY_FOR_DELIVERY
  DELIVERED
}

enum RefundStatus {
  PENDING
  APPROVED
  REJECTED
}

// ==================== VIRTUAL ASSISTANT CHAT (NEW) ====================

model VirtualAssistantChat {
  id              String                        @id @default(uuid()) @db.Uuid
  
  userId          String                        @db.Uuid
  user            User                          @relation("UserVAChats", fields: [userId], references: [id], onDelete: Cascade)
  
  householdItemId String                        @db.Uuid
  householdItem   HouseholdItem                 @relation("ItemVAChats", fields: [householdItemId], references: [id], onDelete: Cascade)
  
  // Chat status
  status          VAChatStatus                  @default(ACTIVE)
  
  // Gatekeeper checkpoints (user must understand before agent contact)
  checkpoint1_ItemTypeUnderstand Boolean        @default(false) // Confirmed item type (stock vs custom)
  checkpoint2_PaymentWarning     Boolean        @default(false) // Confirmed payment non-refundable
  checkpoint3_H12Liability       Boolean        @default(false) // Confirmed H12 liability limits
  checkpoint4_ProcessUnderstand  Boolean        @default(false) // For custom: understood timeline & Day 21 approval
  checkpoint5_FinalConfirm       Boolean        @default(false) // User clicked [I UNDERSTAND]
  
  // Custom item specific
  customizations Json?                          // Selected color, size, material (if custom)
  totalPrice     Float?                         // Calculated price shown to user
  
  // When user ready to proceed
  readyForPayment Boolean                       @default(false)
  readyForPaymentAt DateTime?
  
  messages        VAChatMessage[]
  
  createdAt       DateTime                      @default(now())
  updatedAt       DateTime                      @updatedAt
  
  @@index([userId])
  @@index([householdItemId])
  @@index([status])
  @@map("virtual_assistant_chats")
}

enum VAChatStatus {
  ACTIVE                  // User still chatting with VA
  AWAITING_PAYMENT        // User confirmed, waiting to pay
  COMPLETED               // User paid, moved to agent
  ABANDONED               // User left without paying
}

model VAChatMessage {
  id                String @id @default(uuid()) @db.Uuid
  
  chatId            String @db.Uuid
  chat              VirtualAssistantChat @relation(fields: [chatId], references: [id], onDelete: Cascade)
  
  // Who sent it (USER or SYSTEM/VA)
  senderType        VAChatSenderType
  
  message           String @db.Text
  messageType       VAChatMessageType @default(TEXT)
  
  // If VA sends options (checkpoint confirmations)
  actionRequired    Boolean @default(false)
  actionType        String? // "CONFIRM_UNDERSTANDING", "SELECT_CUSTOMIZATION", etc.
  
  createdAt         DateTime @default(now())
  
  @@index([chatId])
  @@index([createdAt])
  @@map("virtual_assistant_chat_messages")
}

enum VAChatSenderType {
  USER
  VIRTUAL_ASSISTANT
}

enum VAChatMessageType {
  TEXT
  SYSTEM_MESSAGE          // "Please confirm you understand"
  CUSTOMIZATION_OPTIONS   // Shows color/size choices
  PAYMENT_CONFIRMATION    // Shows total price
  FINAL_CONFIRMATION      // "Ready to proceed?"
}

// ==================== CHAT SYSTEM - REAL ESTATE ====================

enum ChatStatus {
  OPEN                    // Chat just created, agent hasn't responded
  ACTIVE                  // Agent has engaged with user
  PAYMENT_RECEIVED        // Admin confirmed payment received
  CLOSED                  // Chat closed by admin
  CANCELLED               // User cancelled before completion
}

enum ChatMessageType {
  TEXT                    // Normal message
  SYSTEM                  // System notification
  ADMIN_NOTIFICATION      // Admin alert
  AGENT_NOTIFICATION      // Agent specific notification
}

enum AgentActionType {
  CHAT_ASSIGNED           // Chat assigned to agent
  MESSAGE_SENT            // Agent sent message
  MESSAGE_READ            // Agent read user message
  FIRST_RESPONSE          // Agent's first response
  CALL_INITIATED          // Agent called user
  CALL_ENDED              // Call ended
  PAYMENT_CONFIRMED       // Admin confirmed payment
  CHAT_CLOSED             // Chat closed
}

enum AgentPaymentStatus {
  PENDING                 // Waiting for user payment
  PAYMENT_RECEIVED        // User payment confirmed by admin
  AGENT_PAID              // Agent has been paid
  CANCELLED               // Transaction cancelled
  FAILED                  // Payment failed
}

enum UserRatingCategory {
  RESPONSIVENESS
  PROFESSIONALISM
  HELPFULNESS
  KNOWLEDGE
  TRUSTWORTHINESS
  OVERALL
}

enum ReportReason {
  UNPROFESSIONAL_CONDUCT
  UNRESPONSIVE
  MISLEADING_INFORMATION
  FRAUD_ATTEMPT
  OTHER
}

model Chat {
  id                        String                @id @default(uuid()) @db.Uuid
  
  // Core relationships
  userId                    String                @db.Uuid
  user                      User                  @relation("ChatUser", fields: [userId], references: [id], onDelete: Cascade)
  
  agentId                   String                @db.Uuid
  agent                     User                  @relation("ChatAgent", fields: [agentId], references: [id], onDelete: Cascade)
  
  propertyId                String                @db.Uuid
  property                  Item                  @relation("ChatProperty", fields: [propertyId], references: [id], onDelete: Cascade)
  
  // Chat status
  status                    ChatStatus            @default(OPEN)
  
  // Messages
  messages                  ChatMessageModel[]
  
  // Agent responsiveness tracking
  createdAt                 DateTime              @default(now())
  firstAgentResponseAt      DateTime?             // When agent first responded
  lastAgentResponseAt       DateTime?             // Latest agent response
  agentResponseCount        Int                   @default(0)
  agentFeePayment           AgentFeePayment?      @relation("AgentFeePayment")
  
  // User activity
  userMessageCount          Int                   @default(0)
  lastUserMessageAt         DateTime?
  
  // Agent performance metrics
  averageResponseTimeMinutes Int?                 // Time between user msg and agent response
  wasAgentResponsive        Boolean               @default(false) // True if responded within 24h
  agentMissedFirstResponse  Boolean               @default(false) // Didn't respond in 24h
  
  // Payment tracking
  paymentReceivedAt         DateTime?             // When admin marked payment received
  agentPaymentStatus        AgentPaymentStatus    @default(PENDING)
  
  // Agent fee details (shown in chat for transparency)
  agentFeeAmount            Float?                // Amount agent will receive
  agentFeePercentage        Float?                // Percentage of deal (e.g., 10%)
  agentPaymentAccountDetails Json?                // { bankName, accountNumber, accountName }
  agentPaidAt               DateTime?
  
  // Chat closure
  closedAt                  DateTime?
  closedByAdminId           String?               @db.Uuid
  closedByAdmin             User?                 @relation("ChatClosedByAdmin", fields: [closedByAdminId], references: [id])
  closureReason             String?               // PAYMENT_RECEIVED, USER_CANCELLED, AGENT_INACTIVE
  
  // User rating & review
  userRating                UserRating?
  
  // Reports
  reports                   ConversationReport[]
  
  // Activity logs
  activityLogs              AgentActivityLog[]
  
  updatedAt                 DateTime              @updatedAt
  
  @@index([userId])
  @@index([agentId])
  @@index([propertyId])
  @@index([status])
  @@index([createdAt])
  @@index([paymentReceivedAt])
  @@map("chats")
}

model ChatMessageModel {
  id                        String                @id @default(uuid()) @db.Uuid
  
  chatId                    String                @db.Uuid
  chat                      Chat                  @relation(fields: [chatId], references: [id], onDelete: Cascade)
  
  // Who sent it
  senderId                  String                @db.Uuid
  sender                    User                  @relation("ChatMessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  
  // Message content
  message                   String                @db.Text
  messageType               ChatMessageType       @default(TEXT)
  
  // Message read tracking
  readAt                    DateTime?             // When recipient read message
  
  // Metadata for audit trail
  metadata                  Json?                 // { ipAddress, deviceInfo, location }
  
  createdAt                 DateTime              @default(now())
  updatedAt                 DateTime              @updatedAt
  
  @@index([chatId])
  @@index([senderId])
  @@index([createdAt])
  @@map("chat_messages_model")
}

model UserRating {
  id                        String                @id @default(uuid()) @db.Uuid
  
  chatId                    String                @db.Uuid @unique
  chat                      Chat                  @relation(fields: [chatId], references: [id], onDelete: Cascade)
  
  userId                    String                @db.Uuid
  user                      User                  @relation("UserGivenRatings", fields: [userId], references: [id], onDelete: Cascade)
  
  agentId                   String                @db.Uuid
  agent                     User                  @relation("UserReceivedRatings", fields: [agentId], references: [id], onDelete: Cascade)
  
  // Rating categories (1-5 stars)
  responsivenessRating      Int?                  // 1-5
  professionalismRating     Int?                  // 1-5
  helpfulnessRating         Int?                  // 1-5
  knowledgeRating           Int?                  // 1-5
  trustworthinessRating     Int?                  // 1-5
  overallRating             Int                   // 1-5 REQUIRED
  
  // Review text
  reviewText                String?               @db.Text
  
  // Tip for good service
  tipAmount                 Float?                // User can tip agent
  tipPaid                   Boolean               @default(false)
  tipPaidAt                 DateTime?
  
  // Admin follow-up
  adminRequestedRating      Boolean               @default(false)
  adminRequestedAt          DateTime?
  
  createdAt                 DateTime              @default(now())
  updatedAt                 DateTime              @updatedAt
  
  @@index([chatId])
  @@index([userId])
  @@index([agentId])
  @@index([overallRating])
  @@map("user_ratings")
}

model AgentStatistics {
  id                        String                @id @default(uuid()) @db.Uuid
  
  agentId                   String                @db.Uuid @unique
  agent                     User                  @relation("AgentStats", fields: [agentId], references: [id], onDelete: Cascade)
  
  // Chat metrics
  totalChatsAssigned        Int                   @default(0)
  totalChatsCompleted       Int                   @default(0)
  totalChatsCancelled       Int                   @default(0)
  
  // Response metrics
  averageResponseTimeMinutes Int?
  responsesWithin24Hours    Int                   @default(0)
  responsesAfter24Hours     Int                   @default(0)
  
  // Rating metrics
  averageOverallRating      Float?
  averageResponsivenessRating Float?
  averageProfessionalismRating Float?
  averageHelpfulnessRating  Float?
  totalRatingsReceived      Int                   @default(0)
  
  // Earnings
  totalEarnings             Float                 @default(0)
  totalTipsEarned           Float                 @default(0)
  
  // Activity
  lastActivityAt            DateTime?
  
  // Status
  isActive                  Boolean               @default(true)
  isWarned                  Boolean               @default(false)
  banReason                 String?
  bannedAt                  DateTime?
  
  updatedAt                 DateTime              @updatedAt
  
  @@index([agentId])
  @@index([averageOverallRating])
  @@map("agent_statistics")
}

model AgentActivityLog {
  id                        String                @id @default(uuid()) @db.Uuid
  
  chatId                    String                @db.Uuid
  chat                      Chat                  @relation(fields: [chatId], references: [id], onDelete: Cascade)
  
  agentId                   String                @db.Uuid
  agent                     User                  @relation("AgentActivityLogs", fields: [agentId], references: [id], onDelete: Cascade)
  
  // Action type
  actionType                AgentActionType
  
  // Additional context
  metadata                  Json?
  
  // For audit
  ipAddress                 String?
  userAgent                 String?
  
  createdAt                 DateTime              @default(now())
  
  @@index([chatId])
  @@index([agentId])
  @@index([actionType])
  @@index([createdAt])
  @@map("agent_activity_logs")
}

model ConversationReport {
  id                        String                @id @default(uuid()) @db.Uuid
  
  chatId                    String                @db.Uuid
  chat                      Chat                  @relation(fields: [chatId], references: [id], onDelete: Cascade)
  
  userId                    String                @db.Uuid
  user                      User                  @relation("UserReports", fields: [userId], references: [id], onDelete: Cascade)
  
  reportedAgentId           String                @db.Uuid
  reportedAgent             User                  @relation("AgentReportedFor", fields: [reportedAgentId], references: [id])
  
  // Report details
  reason                    ReportReason
  description               String                @db.Text
  
  // Admin review
  reviewedByAdminId         String?               @db.Uuid
  reviewedByAdmin           User?                 @relation("AdminReviews", fields: [reviewedByAdminId], references: [id])
  reviewedAt                DateTime?
  adminNotes                String?
  actionTaken               String?
  
  createdAt                 DateTime              @default(now())
  updatedAt                 DateTime              @updatedAt
  
  @@index([chatId])
  @@index([userId])
  @@index([reportedAgentId])
  @@map("conversation_reports")
}

model AgentFeePayment {
  id                        String                @id @default(uuid()) @db.Uuid
  
  chatId                    String                @db.Uuid @unique
  chat                      Chat                  @relation("AgentFeePayment", fields: [chatId], references: [id], onDelete: Cascade)
  agentId                   String                @db.Uuid
  agent                     User                  @relation("AgentFeePayments", fields: [agentId], references: [id])
  
  // Payment details
  amount                    Float
  percentage                Float
  
  // Bank details
  bankName                  String
  accountNumber             String
  accountName               String
  
  // Payment status
  status                    AgentPaymentStatus    @default(PENDING)
  
  // Payment confirmation
  userPaymentConfirmedAt    DateTime?
  agentPaymentConfirmedAt   DateTime?
  
  // Metadata
  metadata                  Json?
  
  createdAt                 DateTime              @default(now())
  updatedAt                 DateTime              @updatedAt
  
  @@index([chatId])
  @@index([agentId])
  @@index([status])
  @@map("agent_fee_payments")
}

// ==================== ANALYTICS / ENGAGEMENT ====================

model PropertyView {
  id         String   @id @default(uuid()) @db.Uuid
  propertyId String   @db.Uuid
  userId     String?  @db.Uuid
  ipAddress  String?
  userAgent  String?
  referrer   String?
  sessionId  String?
  viewedAt   DateTime @default(now())

  property Item  @relation("PropertyViews", fields: [propertyId], references: [id], onDelete: Cascade)
  user     User? @relation("UserPropertyViews", fields: [userId], references: [id], onDelete: SetNull)

  @@index([propertyId])
  @@index([userId])
  @@index([ipAddress])
  @@index([viewedAt])
  @@map("property_views")
}

model PropertyEngagement {
  id         String         @id @default(uuid()) @db.Uuid
  propertyId String         @db.Uuid
  userId     String?        @db.Uuid
  actionType EngagementType
  metadata   Json?
  createdAt  DateTime       @default(now())

  property Item  @relation("PropertyEngagements", fields: [propertyId], references: [id], onDelete: Cascade)
  user     User? @relation("UserEngagements", fields: [userId], references: [id], onDelete: SetNull)

  @@index([propertyId])
  @@index([userId])
  @@index([actionType])
  @@index([createdAt])
  @@map("property_engagements")
}

enum EngagementType {
  CLICKED_INTERESTED
  OPENED_WHATSAPP
  CLICKED_PHONE
  VIEWED_IMAGE
  SHARED_PROPERTY
  BOOKMARKED
  CLICKED_DIRECTIONS
  DOWNLOADED_BROCHURE
}

// ==================== INTERESTS / CHAT ====================

enum InterestStatus {
  ACTIVE
  PURCHASED
  CANCELLED
  EXPIRED
}

enum MessageType {
  TEXT
  IMAGE
  PAYMENT_PROOF
  SYSTEM
}

enum SaleStatus {
  PENDING
  PAYMENT_SUBMITTED
  CONFIRMED
  DELIVERED
  CANCELLED
  DISPUTED
}

model PropertyInterest {
  id         String         @id @default(uuid()) @db.Uuid
  propertyId String         @db.Uuid
  userId     String         @db.Uuid
  status     InterestStatus @default(ACTIVE)
  createdAt  DateTime       @default(now())
  updatedAt  DateTime       @updatedAt

  property Item @relation("PropertyInterests", fields: [propertyId], references: [id], onDelete: Cascade)
  user     User @relation("UserInterests", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([propertyId, userId])
  @@index([propertyId])
  @@index([userId])
  @@index([status])
  @@map("property_interests")
}

model ChatMessage {
  id            String      @id @default(uuid()) @db.Uuid
  propertyId    String      @db.Uuid
  senderId      String      @db.Uuid
  receiverId    String      @db.Uuid
  message       String      @db.Text
  messageType   MessageType @default(TEXT)
  attachmentUrl String?
  isRead        Boolean     @default(false)
  readAt        DateTime?
  createdAt     DateTime    @default(now())

  property Item @relation("PropertyMessages", fields: [propertyId], references: [id], onDelete: Cascade)
  sender   User @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  receiver User @relation("ReceivedMessages", fields: [receiverId], references: [id], onDelete: Cascade)

  @@index([propertyId])
  @@index([senderId])
  @@index([receiverId])
  @@index([createdAt])
  @@map("chat_messages")
}

// ==================== SALES / DEALS / PAYMENTS ====================

model Sale {
  id                 String     @id @default(uuid()) @db.Uuid
  propertyId         String     @db.Uuid
  buyerId            String     @db.Uuid
  sellerId           String     @db.Uuid
  amount             Float
  paymentProofUrl    String?
  companyAccountPaid Boolean    @default(false)
  status             SaleStatus @default(PENDING)
  markedSoldAt       DateTime?
  deliveredAt        DateTime?
  notes              String?    @db.Text

  isRental        Boolean   @default(false)
  rentalMonths    Int?
  rentalStartDate DateTime?
  rentalEndDate   DateTime?

  // NEW: manual payment details + finance review
  paymentMethod       PaymentMethod?
  paymentReference    String?
  financeStatus       FinanceStatus  @default(PENDING)
  financeReviewedById String?        @db.Uuid
  financeReviewedBy   User?          @relation("FinanceReviewedSales", fields: [financeReviewedById], references: [id])
  financeReviewedAt   DateTime?
  financeComment      String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  property Item @relation("PropertySales", fields: [propertyId], references: [id], onDelete: Cascade)
  buyer    User @relation("Purchases", fields: [buyerId], references: [id], onDelete: Cascade)
  seller   User @relation("Sales", fields: [sellerId], references: [id], onDelete: Cascade)

  // NEW: linked payments & commissions
  payments    Payment[]
  commissions Commission[]

  @@index([propertyId])
  @@index([buyerId])
  @@index([sellerId])
  @@index([status])
  @@index([createdAt])
  @@map("sales")
}

// Payment providers for manual and Paystack phases
enum PaymentProvider {
  MANUAL_TRANSFER
  PAYSTACK
}

enum PaymentStatus {
  PENDING
  SUCCESS
  FAILED
  REFUNDED
}

enum PaymentMethod {
  BANK_TRANSFER
  CASH_DEPOSIT
  CARD
  OTHER
}

enum FinanceStatus {
  PENDING
  CONFIRMED
  REJECTED
}

enum CommissionStatus {
  PENDING
  APPROVED
  PAID
  REJECTED
}

// All money flows
model Payment {
  id         String          @id @default(uuid()) @db.Uuid
  saleId     String          @db.Uuid
  userId     String          @db.Uuid
  propertyId String          @db.Uuid
  provider   PaymentProvider
  status     PaymentStatus   @default(PENDING)
  amount     Float
  currency   String          @default("NGN")
  reference  String?         @unique
  rawData    Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sale     Sale @relation(fields: [saleId], references: [id], onDelete: Cascade)
  user     User @relation(fields: [userId], references: [id], onDelete: Cascade)
  property Item @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  @@index([saleId])
  @@index([userId])
  @@index([propertyId])
  @@index([status])
  @@map("payments")
}

// ==================== VIEWING FEE PAYMENTS ====================

model ViewingFeePayment {
  id                String        @id @default(uuid()) @db.Uuid
  userId            String        @db.Uuid
  propertyId        String        @db.Uuid
  amount            Float
  paystackReference String        @unique
  status            PaymentStatus @default(PENDING)
  paidAt            DateTime?
  
  // Commission splits
  agentShare        Float
  companyShare      Float
  
  // Metadata
  metadata          Json?
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  user     User @relation("UserViewingFees", fields: [userId], references: [id], onDelete: Cascade)
  property Item @relation("PropertyViewingFees", fields: [propertyId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([propertyId])
  @@index([status])
  @@index([paystackReference])
  @@map("viewing_fee_payments")
}

// NEW: Reservation Fee Payments for Real Estate (House Renting/Selling)
model ReservationFeePayment {
  id                String                @id @default(uuid()) @db.Uuid
  
  // User & Property
  userId            String                @db.Uuid
  user              User                  @relation("ReservationFeePayments", fields: [userId], references: [id], onDelete: Cascade)
  propertyId        String                @db.Uuid
  property          Item                  @relation("PropertyReservationFees", fields: [propertyId], references: [id], onDelete: Cascade)
  
  // Payment details (₦10,000 non-refundable reservation fee)
  amount            Float                 @default(10000)  // ₦10,000 NON-REFUNDABLE
  paystackReference String                @unique
  status            PaymentStatus         @default(PENDING)
  paidAt            DateTime?
  
  // H12 keeps 100% of reservation fee (NO refunds)
  h12KeepsAmount    Float                 // H12 keeps 100% (non-refundable)
  
  // Agent fee (only paid if deal completes, not on reservation)
  agentFeeAmount    Float?                // Agent commission paid after deal success
  agentFeePaidAt    DateTime?
  
  metadata          Json?
  
  createdAt         DateTime              @default(now())
  updatedAt         DateTime              @updatedAt
  
  @@index([userId])
  @@index([propertyId])
  @@index([status])
  @@map("reservation_fee_payments")
}

enum ReservationFeeStatus {
  PENDING
  PAID
  REFUNDED
}

// NEW: Household items payments (similar to viewing fee payments)
model HouseholdItemPayment {
  id                String                @id @default(uuid()) @db.Uuid
  
  orderId           String                @db.Uuid
  order             HouseholdItemOrder    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  
  userId            String                @db.Uuid
  amount            Float
  paystackReference String                @unique
  status            PaymentStatus         @default(PENDING)
  paidAt            DateTime?
  
  // Commission breakdown
  h12CommissionPercent Float               @default(10)
  h12CommissionAmount  Float
  sellerAmount         Float
  
  metadata          Json?
  
  createdAt         DateTime              @default(now())
  updatedAt         DateTime              @updatedAt
  
  @@index([orderId])
  @@index([userId])
  @@index([status])
  @@map("household_item_payments")
}

// Commissions for admins/agents
model Commission {
  id        String           @id @default(uuid()) @db.Uuid
  saleId    String           @db.Uuid
  adminId   String           @db.Uuid
  amount    Float
  status    CommissionStatus @default(PENDING)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  sale  Sale @relation(fields: [saleId], references: [id], onDelete: Cascade)
  admin User @relation("AdminCommissions", fields: [adminId], references: [id], onDelete: Cascade)

  @@index([saleId])
  @@index([adminId])
  @@map("commissions")
}

// ==================== AUDIT ====================

model AuditLog {
  id         String   @id @default(uuid()) @db.Uuid
  userId     String?  @db.Uuid
  action     String
  entityType String
  entityId   String?  @db.Uuid
  metadata   Json?
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime @default(now())

  user User? @relation("UserAuditLogs", fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([action])
  @@index([entityType])
  @@index([createdAt])
  @@map("audit_logs")
}

// ==================== LANDLORD & VERIFICATION ====================

model Landlord {
  id       String  @id @default(uuid()) @db.Uuid
  fullName String
  phone    String?
  email    String?
  address  String?

  // Account details to pay landlord
  bankName      String?
  accountNumber String?
  accountName   String?

  // Verification
  verificationStatus LandlordVerificationStatus @default(PENDING)
  nationalIdUrl      String?
  utilityBillUrl     String?
  cacDocUrl          String?

  receiptProofs ReceiptProof[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  properties PropertyToLandlord[]
}

enum LandlordVerificationStatus {
  PENDING
  VERIFIED
  REJECTED
}

model PropertyToLandlord {
  id String @id @default(uuid()) @db.Uuid

  propertyId String @db.Uuid
  landlordId String @db.Uuid

  createdAt DateTime @default(now())

  property Item     @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  landlord Landlord @relation(fields: [landlordId], references: [id], onDelete: Cascade)

  @@index([propertyId])
  @@index([landlordId])
}

model ReceiptProof {
  id         String @id @default(uuid()) @db.Uuid
  propertyId String @db.Uuid
  buyerId    String @db.Uuid
  landlordId String @db.Uuid

  receiptUrl String
  amountPaid Float
  paidAt     DateTime

  status        ReceiptStatus @default(PENDING)
  reviewerId    String?       @db.Uuid
  reviewedAt    DateTime?
  reviewComment String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  property Item @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  buyer User @relation("ReceiptBuyer", fields: [buyerId], references: [id], onDelete: Cascade)

  landlord Landlord @relation(fields: [landlordId], references: [id], onDelete: Cascade)

  reviewer User? @relation("ReceiptReviewer", fields: [reviewerId], references: [id])

  @@index([propertyId])
  @@index([buyerId])
  @@index([landlordId])
  @@index([status])
}

enum ReceiptStatus {
  PENDING
  APPROVED
  REJECTED
  FRAUD_SUSPECT
}

model TermsAgreement {
  id           String   @id @default(uuid()) @db.Uuid
  userId       String   @db.Uuid
  propertyId   String?  @db.Uuid
  termsVersion String
  agreedAt     DateTime @default(now())
  ipAddress    String?
  userAgent    String?

  user     User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  property Item? @relation(fields: [propertyId], references: [id], onDelete: SetNull)

  quizSubmissions TermsQuizSubmission[]

  @@index([userId])
  @@index([propertyId])
}

model TermsQuizSubmission {
  id          String   @id @default(uuid()) @db.Uuid
  agreementId String   @db.Uuid
  score       Int
  passed      Boolean
  answers     Json
  submittedAt DateTime @default(now())

  agreement TermsAgreement @relation(fields: [agreementId], references: [id], onDelete: Cascade)
}
