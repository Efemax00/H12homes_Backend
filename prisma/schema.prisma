generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ==================== AUTH & CORE ====================

model RefreshToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String   @db.Uuid
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([token])
}

model User {
  id         String  @id @default(uuid()) @db.Uuid
  email      String  @unique
  phone      String?
  password   String
  location   String?
  firstName  String  @map("first_name")
  middleName String? @map("middle_name")
  lastName   String  @map("last_name")
  avatarUrl  String? @map("avatar_url")
  role       Role    @default(USER)

  ownedProperties Item[] @relation("OwnerRelation")
  agentListings   Item[] @relation("AgentRelation")

  receiptProofsAsBuyer    ReceiptProof[]   @relation("ReceiptBuyer")
  receiptProofsAsReviewer ReceiptProof[]   @relation("ReceiptReviewer")
  termsAgreements         TermsAgreement[]

  failedLoginAttempts Int            @default(0)
  accountLockedUntil  DateTime?
  refreshTokens       RefreshToken[]
  lastLoginAttempt    DateTime?

  interests        PropertyInterest[]   @relation("UserInterests")
  sentMessages     ChatMessage[]        @relation("SentMessages")
  receivedMessages ChatMessage[]        @relation("ReceivedMessages")
  purchases        Sale[]               @relation("Purchases")
  sales            Sale[]               @relation("Sales")
  auditLogs        AuditLog[]           @relation("UserAuditLogs")
  propertyViews    PropertyView[]       @relation("UserPropertyViews")
  engagements      PropertyEngagement[] @relation("UserEngagements")

  itemsCreated Item[] @relation("ItemCreatedBy")

  // NEW: payments, commissions, finance reviews
  payments             Payment[]
  adminCommissions     Commission[] @relation("AdminCommissions")
  financeReviewedSales Sale[]       @relation("FinanceReviewedSales")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  passwordResetToken          String?   @unique
  passwordResetTokenExpiresAt DateTime?

  isEmailVerified                 Boolean   @default(false)
  emailVerificationToken          String?   @unique
  emailVerificationTokenExpiresAt DateTime?
}

enum Role {
  USER
  SELLER
  ADMIN
  SUPER_ADMIN
}

// ==================== ITEMS / PROPERTIES ====================

model Item {
  id          String     @id @default(uuid()) @db.Uuid
  title       String
  shortDesc   String
  longDesc    String
  dos         String?
  donts       String?
  price       Float
  location    String
  contactInfo String?
  status      ItemStatus @default(PENDING)
  isFeatured  Boolean    @default(false)

  rentStartDate      DateTime?
  rentEndDate        DateTime?
  rentDurationMonths Int?
  autoReopenAt       DateTime?

  category ItemCategory @default(FOR_SALE)
  itemType ItemType     @default(HOUSE)

  bedrooms     Int?
  bathrooms    Int?
  sqft         Float?
  propertyType String?

  viewCount          Int       @default(0)
  uniqueViewCount    Int       @default(0)
  interestedCount    Int       @default(0)
  whatsappClickCount Int       @default(0)
  lastViewedAt       DateTime?

  interests   PropertyInterest[]   @relation("PropertyInterests")
  messages    ChatMessage[]        @relation("PropertyMessages")
  sales       Sale[]               @relation("PropertySales")
  views       PropertyView[]       @relation("PropertyViews")
  engagements PropertyEngagement[] @relation("PropertyEngagements")

  agentCommissionPercent   Float @default(0)
  companyCommissionPercent Float @default(0)
  ownerCommissionPercent   Float @default(0)
  platformFeePercent       Float @default(0)

  landlordLinks   PropertyToLandlord[]
  receiptProofs   ReceiptProof[]
  termsAgreements TermsAgreement[]

  ownerId String? @db.Uuid
  owner   User?   @relation("OwnerRelation", fields: [ownerId], references: [id], onDelete: SetNull)

  agentId String? @db.Uuid
  agent   User?   @relation("AgentRelation", fields: [agentId], references: [id], onDelete: SetNull)

  // NEW: payments related to this property
  payments Payment[]

  isDeleted      Boolean   @default(false)
  deletedAt      DateTime?
  deletedBy      String?   @db.Uuid
  deletionReason String?

  createdBy     String? @db.Uuid
  createdByUser User?   @relation("ItemCreatedBy", fields: [createdBy], references: [id])

  images ItemImage[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([isDeleted])
}

model ItemImage {
  id    String @id @default(uuid()) @db.Uuid
  url   String
  order Int    @default(0)

  itemId String @db.Uuid
  item   Item   @relation(fields: [itemId], references: [id])
}

enum ItemStatus {
  PENDING
  AVAILABLE
  SOLD
  REJECTED
  RENTED
}

enum ItemCategory {
  FOR_SALE
  FOR_RENT
  SHORT_STAY
}

enum ItemType {
  HOUSE
  HOUSEHOLD_ITEM
}

// ==================== ANALYTICS / ENGAGEMENT ====================

model PropertyView {
  id         String   @id @default(uuid()) @db.Uuid
  propertyId String   @db.Uuid
  userId     String?  @db.Uuid // Null if not logged in
  ipAddress  String? // Track anonymous users
  userAgent  String? // Device/browser info
  referrer   String? // Where they came from
  sessionId  String? // Group views in same session
  viewedAt   DateTime @default(now())

  property Item  @relation("PropertyViews", fields: [propertyId], references: [id], onDelete: Cascade)
  user     User? @relation("UserPropertyViews", fields: [userId], references: [id], onDelete: SetNull)

  @@index([propertyId])
  @@index([userId])
  @@index([ipAddress])
  @@index([viewedAt])
  @@map("property_views")
}

model PropertyEngagement {
  id         String         @id @default(uuid()) @db.Uuid
  propertyId String         @db.Uuid
  userId     String?        @db.Uuid
  actionType EngagementType
  metadata   Json?
  createdAt  DateTime       @default(now())

  property Item  @relation("PropertyEngagements", fields: [propertyId], references: [id], onDelete: Cascade)
  user     User? @relation("UserEngagements", fields: [userId], references: [id], onDelete: SetNull)

  @@index([propertyId])
  @@index([userId])
  @@index([actionType])
  @@index([createdAt])
  @@map("property_engagements")
}

enum EngagementType {
  CLICKED_INTERESTED
  OPENED_WHATSAPP
  CLICKED_PHONE
  VIEWED_IMAGE
  SHARED_PROPERTY
  BOOKMARKED
  CLICKED_DIRECTIONS
  DOWNLOADED_BROCHURE
}

// ==================== INTERESTS / CHAT ====================

enum InterestStatus {
  ACTIVE
  PURCHASED
  CANCELLED
  EXPIRED
}

enum MessageType {
  TEXT
  IMAGE
  PAYMENT_PROOF
  SYSTEM
}

enum SaleStatus {
  PENDING
  PAYMENT_SUBMITTED
  CONFIRMED
  DELIVERED
  CANCELLED
  DISPUTED
}

model PropertyInterest {
  id         String         @id @default(uuid()) @db.Uuid
  propertyId String         @db.Uuid
  userId     String         @db.Uuid
  status     InterestStatus @default(ACTIVE)
  createdAt  DateTime       @default(now())
  updatedAt  DateTime       @updatedAt

  property Item @relation("PropertyInterests", fields: [propertyId], references: [id], onDelete: Cascade)
  user     User @relation("UserInterests", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([propertyId, userId])
  @@index([propertyId])
  @@index([userId])
  @@index([status])
  @@map("property_interests")
}

model ChatMessage {
  id            String      @id @default(uuid()) @db.Uuid
  propertyId    String      @db.Uuid
  senderId      String      @db.Uuid
  receiverId    String      @db.Uuid
  message       String      @db.Text
  messageType   MessageType @default(TEXT)
  attachmentUrl String?
  isRead        Boolean     @default(false)
  readAt        DateTime?
  createdAt     DateTime    @default(now())

  property Item @relation("PropertyMessages", fields: [propertyId], references: [id], onDelete: Cascade)
  sender   User @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  receiver User @relation("ReceivedMessages", fields: [receiverId], references: [id], onDelete: Cascade)

  @@index([propertyId])
  @@index([senderId])
  @@index([receiverId])
  @@index([createdAt])
  @@map("chat_messages")
}

// ==================== SALES / DEALS / PAYMENTS ====================

model Sale {
  id                 String     @id @default(uuid()) @db.Uuid
  propertyId         String     @db.Uuid
  buyerId            String     @db.Uuid
  sellerId           String     @db.Uuid
  amount             Float
  paymentProofUrl    String?
  companyAccountPaid Boolean    @default(false)
  status             SaleStatus @default(PENDING)
  markedSoldAt       DateTime?
  deliveredAt        DateTime?
  notes              String?    @db.Text

  isRental        Boolean   @default(false)
  rentalMonths    Int?
  rentalStartDate DateTime?
  rentalEndDate   DateTime?

  // NEW: manual payment details + finance review
  paymentMethod       PaymentMethod?
  paymentReference    String?
  financeStatus       FinanceStatus  @default(PENDING)
  financeReviewedById String?        @db.Uuid
  financeReviewedBy   User?          @relation("FinanceReviewedSales", fields: [financeReviewedById], references: [id])
  financeReviewedAt   DateTime?
  financeComment      String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  property Item @relation("PropertySales", fields: [propertyId], references: [id], onDelete: Cascade)
  buyer    User @relation("Purchases", fields: [buyerId], references: [id], onDelete: Cascade)
  seller   User @relation("Sales", fields: [sellerId], references: [id], onDelete: Cascade)

  // NEW: linked payments & commissions
  payments    Payment[]
  commissions Commission[]

  @@index([propertyId])
  @@index([buyerId])
  @@index([sellerId])
  @@index([status])
  @@index([createdAt])
  @@map("sales")
}

// Payment providers for manual and Paystack phases
enum PaymentProvider {
  MANUAL_TRANSFER
  PAYSTACK
}

enum PaymentStatus {
  PENDING
  SUCCESS
  FAILED
  REFUNDED
}

enum PaymentMethod {
  BANK_TRANSFER
  CASH_DEPOSIT
  CARD
  OTHER
}

enum FinanceStatus {
  PENDING
  CONFIRMED
  REJECTED
}

enum CommissionStatus {
  PENDING
  APPROVED
  PAID
  REJECTED
}

// All money flows
model Payment {
  id         String          @id @default(uuid()) @db.Uuid
  saleId     String          @db.Uuid
  userId     String          @db.Uuid
  propertyId String          @db.Uuid
  provider   PaymentProvider
  status     PaymentStatus   @default(PENDING)
  amount     Float
  currency   String          @default("NGN")
  reference  String?         @unique // Paystack ref or bank narration
  rawData    Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sale     Sale @relation(fields: [saleId], references: [id], onDelete: Cascade)
  user     User @relation(fields: [userId], references: [id], onDelete: Cascade)
  property Item @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  @@index([saleId])
  @@index([userId])
  @@index([propertyId])
  @@index([status])
  @@map("payments")
}

// Commissions for admins/agents
model Commission {
  id        String           @id @default(uuid()) @db.Uuid
  saleId    String           @db.Uuid
  adminId   String           @db.Uuid
  amount    Float
  status    CommissionStatus @default(PENDING)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  sale  Sale @relation(fields: [saleId], references: [id], onDelete: Cascade)
  admin User @relation("AdminCommissions", fields: [adminId], references: [id], onDelete: Cascade)

  @@index([saleId])
  @@index([adminId])
  @@map("commissions")
}

// ==================== AUDIT ====================

model AuditLog {
  id         String   @id @default(uuid()) @db.Uuid
  userId     String?  @db.Uuid
  action     String
  entityType String
  entityId   String?  @db.Uuid
  metadata   Json?
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime @default(now())

  user User? @relation("UserAuditLogs", fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([action])
  @@index([entityType])
  @@index([createdAt])
  @@map("audit_logs")
}

model Landlord {
  id       String  @id @default(uuid()) @db.Uuid
  fullName String
  phone    String?
  email    String?
  address  String?

  // Account details to pay landlord
  bankName      String?
  accountNumber String?
  accountName   String?

  // Verification
  verificationStatus LandlordVerificationStatus @default(PENDING)
  nationalIdUrl      String? // ID card photo
  utilityBillUrl     String? // Proof of residence
  cacDocUrl          String? // For corporate landlords

  receiptProofs ReceiptProof[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  properties PropertyToLandlord[]
}

enum LandlordVerificationStatus {
  PENDING
  VERIFIED
  REJECTED
}

model PropertyToLandlord {
  id String @id @default(uuid()) @db.Uuid

  propertyId String @db.Uuid
  landlordId String @db.Uuid

  createdAt DateTime @default(now())

  property Item     @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  landlord Landlord @relation(fields: [landlordId], references: [id], onDelete: Cascade)

  @@index([propertyId])
  @@index([landlordId])
}

model ReceiptProof {
  id         String @id @default(uuid()) @db.Uuid
  propertyId String @db.Uuid
  buyerId    String @db.Uuid
  landlordId String @db.Uuid

  receiptUrl String
  amountPaid Float
  paidAt     DateTime

  status        ReceiptStatus @default(PENDING)
  reviewerId    String?       @db.Uuid // finance/admin
  reviewedAt    DateTime?
  reviewComment String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  property Item @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  buyer User @relation("ReceiptBuyer", fields: [buyerId], references: [id], onDelete: Cascade)

  landlord Landlord @relation(fields: [landlordId], references: [id], onDelete: Cascade)

  reviewer User? @relation("ReceiptReviewer", fields: [reviewerId], references: [id])

  @@index([propertyId])
  @@index([buyerId])
  @@index([landlordId])
  @@index([status])
}

enum ReceiptStatus {
  PENDING
  APPROVED
  REJECTED
  FRAUD_SUSPECT
}

model TermsAgreement {
  id           String   @id @default(uuid()) @db.Uuid
  userId       String   @db.Uuid
  propertyId   String?  @db.Uuid
  termsVersion String // so updates donâ€™t break legality
  agreedAt     DateTime @default(now())
  ipAddress    String?
  userAgent    String?

  user     User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  property Item? @relation(fields: [propertyId], references: [id], onDelete: SetNull)

  quizSubmissions TermsQuizSubmission[]

  @@index([userId])
  @@index([propertyId])
}

model TermsQuizSubmission {
  id          String   @id @default(uuid()) @db.Uuid
  agreementId String   @db.Uuid
  score       Int
  passed      Boolean
  answers     Json // store question-answer pairs
  submittedAt DateTime @default(now())

  agreement TermsAgreement @relation(fields: [agreementId], references: [id], onDelete: Cascade)
}
